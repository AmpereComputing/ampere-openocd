From f43b40cd4000083abbfa974fd3b6ffe6ce7d3cbe Mon Sep 17 00:00:00 2001
From: Daniel Goehring <dgoehrin@os.amperecomputing.com>
Date: Thu, 28 Jan 2021 16:41:22 -0500
Subject: [PATCH 30/34] ac03: target/board: AmpereOne configs [DO NOT UPSTREAM]

AmpereOne board and target configuration files.

Change-Id: I871d3d3dfa09a0f45cffc8458d50fae26cb38618
Signed-off-by: Daniel Goehring <dgoehrin@os.amperecomputing.com>
---
 tcl/board/ampere_ac03_1s.cfg      |  98 ++++++++
 tcl/board/ampere_ac03_2s.cfg      | 151 +++++++++++
 tcl/target/ampere_ac03.cfg        | 405 ++++++++++++++++++++++++++++++
 tcl/target/ampere_ac03_1s_tap.cfg |  48 ++++
 tcl/target/ampere_ac03_2s_tap.cfg |  61 +++++
 5 files changed, 763 insertions(+)
 create mode 100644 tcl/board/ampere_ac03_1s.cfg
 create mode 100644 tcl/board/ampere_ac03_2s.cfg
 create mode 100644 tcl/target/ampere_ac03.cfg
 create mode 100644 tcl/target/ampere_ac03_1s_tap.cfg
 create mode 100644 tcl/target/ampere_ac03_2s_tap.cfg

diff --git a/tcl/board/ampere_ac03_1s.cfg b/tcl/board/ampere_ac03_1s.cfg
new file mode 100644
index 000000000..0f2664807
--- /dev/null
+++ b/tcl/board/ampere_ac03_1s.cfg
@@ -0,0 +1,98 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# OpenOCD Board Configuration for the AmpereOne and AmpereOne X processors
+#
+# Copyright (c) 2021-2023, Ampere Computing LLC
+#
+
+# Argument Description
+#
+# JTAGFREQ
+# Set the JTAG clock frequency
+# Syntax: -c "set JTAGFREQ {freq_in_khz}"
+#
+# Life-Cycle State (LCS)
+# If not specified, defaults to "Secure LCS"
+# LCS=0, "Secure LCS"
+# LCS=1, "Chip Manufacturing LCS"
+# Syntax: -c "set LCS {0}"
+# Syntax: -c "set LCS {1}"
+#
+# CORELIST_S0
+# Specify available physical cores by number
+# Example syntax to attach to physical cores 16, 17, 94, 95, 128 and 129 for S0
+# Syntax: -c "set CORELIST_S0 {16 17 94 95 128 129}"
+#
+# COREMASK_S0_0
+# Specify available physical cores 0-63 by mask
+# Example syntax to attach to physical cores 16 and 17 for S0
+# Syntax: -c "set COREMASK_S0_0 {0x0000000000030000}"
+#
+# COREMASK_S0_1
+# Specify available physical cores 64-127 by mask
+# Example syntax to attach to physical cores 94 and 95 for S0
+# Syntax: -c "set COREMASK_S0_1 {0x00000000C0000000}"
+#
+# COREMASK_S0_2
+# Specify available physical cores 128 and above by mask
+# Example syntax to attach to physical cores 128 and 129 for S0
+# Syntax: -c "set COREMASK_S0_2 {0x0000000000000003}"
+
+#
+# Configure JTAG speed
+#
+
+if { [info exists JTAGFREQ] } {
+	adapter speed $JTAGFREQ
+} else {
+	adapter speed 100
+}
+
+#
+# Configure Resets
+#
+
+adapter srst delay 100
+jtag_ntrst_delay 100
+reset_config trst_and_srst separate
+
+#
+# Configure JTAG chain and determine IDCODE
+#
+
+source [find target/ampere_ac03_1s_tap.cfg]
+
+#
+# Configure Targets
+#
+
+if { [info exists CORELIST_S0] || [info exists COREMASK_S0_0] || [info exists COREMASK_S0_1] || [info exists COREMASK_S0_2] } {
+	set CHIPNAME s0
+	if { [info exists CORELIST_S0] } {
+		set CORELIST $CORELIST_S0
+	} else {
+		if { [info exists COREMASK_S0_0] } {
+			set COREMASK_0 $COREMASK_S0_0
+		} else {
+			set COREMASK_0 0x0
+		}
+
+		if { [info exists COREMASK_S0_1] } {
+			set COREMASK_1 $COREMASK_S0_1
+		} else {
+			set COREMASK_1 0x0
+		}
+		if { [info exists COREMASK_S0_2] } {
+			set COREMASK_2 $COREMASK_S0_2
+		} else {
+			set COREMASK_2 0x0
+		}
+	}
+} else {
+	set CHIPNAME s0
+	set COREMASK_0 0x1
+	set COREMASK_1 0x0
+	set COREMASK_2 0x0
+}
+
+source [find target/ampere_ac03.cfg]
diff --git a/tcl/board/ampere_ac03_2s.cfg b/tcl/board/ampere_ac03_2s.cfg
new file mode 100644
index 000000000..79724dde0
--- /dev/null
+++ b/tcl/board/ampere_ac03_2s.cfg
@@ -0,0 +1,151 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# OpenOCD Board Configuration for the AmpereOne and AmpereOne X processors
+#
+# Copyright (c) 2021-2023, Ampere Computing LLC
+#
+
+# Argument Description
+#
+# JTAGFREQ
+# Set the JTAG clock frequency
+# Syntax: -c "set JTAGFREQ {freq_in_khz}"
+#
+# Life-Cycle State (LCS)
+# If not specified, defaults to "Secure LCS"
+# LCS=0, "Secure LCS"
+# LCS=1, "Chip Manufacturing LCS"
+# Syntax: -c "set LCS {0}"
+# Syntax: -c "set LCS {1}"
+#
+# CORELIST_S0, CORELIST_S1
+# Specify available physical cores by number
+# Example syntax to attach to physical cores 16, 17, 94, 95, 128 and 129 for S0 and S1
+# Syntax: -c "set CORELIST_S0 {16 17 94 95 128 129}"
+# Syntax: -c "set CORELIST_S1 {16 17 94 95 128 129}"
+#
+# COREMASK_S0_0, COREMASK_S1_0
+# Specify available physical cores 0-63 by mask
+# Example syntax to attach to physical cores 16 and 17 for S0 and S1
+# Syntax: -c "set COREMASK_S0_0 {0x0000000000030000}"
+# Syntax: -c "set COREMASK_S1_0 {0x0000000000030000}"
+#
+# COREMASK_S0_1, COREMASK_S1_1
+# Specify available physical cores 64-127 by mask
+# Example syntax to attach to physical cores 94 and 95 for S0 and S1
+# Syntax: -c "set COREMASK_S0_1 {0x00000000C0000000}"
+# Syntax: -c "set COREMASK_S1_1 {0x00000000C0000000}"
+#
+# COREMASK_S0_2, COREMASK_S1_2
+# Specify available physical cores 128 and above by mask
+# Example syntax to attach to physical cores 128 and 129 for S0 and S1
+# Syntax: -c "set COREMASK_S0_2 {0x0000000000000003}"
+# Syntax: -c "set COREMASK_S1_2 {0x0000000000000003}"
+#
+# SPLITSMP
+# Group all ARMv8 cores per socket into individual SMP sessions
+# If not specified, group ARMv8 cores from both sockets into one SMP session
+# Syntax: -c "set SPLITSMP {}"
+
+#
+# Configure JTAG speed
+#
+
+if { [info exists JTAGFREQ] } {
+	adapter speed $JTAGFREQ
+} else {
+	adapter speed 100
+}
+
+#
+# Configure Board level SMP configuration if necessary
+#
+
+if { ![info exists SPLITSMP] } {
+	# Group dual chip into a single SMP configuration
+	set SMP_STR "target smp"
+	set CORE_INDEX_OFFSET 0
+}
+
+#
+# Configure Resets
+#
+
+adapter srst delay 100
+jtag_ntrst_delay 100
+reset_config trst_and_srst separate
+
+#
+# Configure JTAG chain and determine IDCODE
+#
+
+source [find target/ampere_ac03_2s_tap.cfg]
+
+#
+# Configure Targets
+#
+
+if { [info exists CORELIST_S0] || [info exists COREMASK_S0_0] || [info exists COREMASK_S0_1] || [info exists COREMASK_S0_2] || [info exists CORELIST_S1] || [info exists COREMASK_S1_0] || [info exists COREMASK_S1_1] || [info exists COREMASK_S1_2] } {
+	set CHIPNAME s1
+	if { [info exists CORELIST_S1] } {
+		set CORELIST $CORELIST_S1
+	} else {
+		if { [info exists COREMASK_S1_0] } {
+			set COREMASK_0 $COREMASK_S1_0
+		} else {
+			set COREMASK_0 0x0
+		}
+
+		if { [info exists COREMASK_S1_1] } {
+			set COREMASK_1 $COREMASK_S1_1
+		} else {
+			set COREMASK_1 0x0
+		}
+		if { [info exists COREMASK_S0_2] } {
+			set COREMASK_2 $COREMASK_S1_2
+		} else {
+			set COREMASK_2 0x0
+		}
+	}
+	source [find target/ampere_ac03.cfg]
+
+	set CHIPNAME s0
+	if { [info exists CORELIST_S0] } {
+		set CORELIST $CORELIST_S0
+	} else {
+		if { [info exists COREMASK_S0_0] } {
+			set COREMASK_0 $COREMASK_S0_0
+		} else {
+			set COREMASK_0 0x0
+		}
+
+		if { [info exists COREMASK_S0_1] } {
+			set COREMASK_1 $COREMASK_S0_1
+		} else {
+			set COREMASK_1 0x0
+		}
+		if { [info exists COREMASK_S0_2] } {
+			set COREMASK_2 $COREMASK_S0_2
+		} else {
+			set COREMASK_2 0x0
+		}
+	}
+	source [find target/ampere_ac03.cfg]
+} else {
+	set CHIPNAME s1
+	set COREMASK_0 0x0
+	set COREMASK_1 0x0
+	set COREMASK_2 0x0
+	source [find target/ampere_ac03.cfg]
+
+	set CHIPNAME s0
+	set COREMASK_0 0x1
+	set COREMASK_1 0x0
+	set COREMASK_2 0x0
+	source [find target/ampere_ac03.cfg]
+}
+
+if { ![info exists SPLITSMP] } {
+        # For dual socket SMP configuration, evaluate the string
+        eval $SMP_STR
+}
diff --git a/tcl/target/ampere_ac03.cfg b/tcl/target/ampere_ac03.cfg
new file mode 100644
index 000000000..1472cfd12
--- /dev/null
+++ b/tcl/target/ampere_ac03.cfg
@@ -0,0 +1,405 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# OpenOCD Target Configuration for the AmpereOne and AmpereOne X processors
+#
+# Copyright (c) 2021-2023, Ampere Computing LLC
+#
+
+# Note:
+# One of the following scripts must be called before executing this script.
+# tcl/target/ampere_ac03_1s_tap.cfg
+# tcl/target/ampere_ac03_2s_tap.cfg
+# These scripts establish the TAPs in the JTAG chain and initialize the
+# "idcode" variable used in this script.
+#
+# Command Line Argument Description
+#
+# SPLITSMP
+# Only used for dual socket systems. Do not use for a single socket setup.
+# Option pertains to the ARMv8 target core naming in a dual socket setup.
+# If specified, name all ARMv8 cores per socket as individual SMP sessions.
+# If not specified, name ARMv8 cores from both sockets as one SMP session.
+# This option is used in conjunction with the SMP_STR board file option.
+# Syntax: -c "set SPLITSMP {}"
+#
+# CHIPNAME
+# Specifies the chip socket.
+# Will typically be either s0 or s1
+# If not specified, defaults to s0
+# Syntax: -c "set CHIPNAME {s0}"
+#
+# Life-Cycle State (LCS)
+# If not specified, defaults to "Secure LCS"
+# LCS=0, "Secure LCS"
+# LCS=1, "Chip Manufacturing LCS"
+# Syntax: -c "set LCS {0}"
+# Syntax: -c "set LCS {1}"
+#
+# Automated Test Environment State (ATE)
+# If not specified, disables ATE boot mode
+# ATE=0, ATE boot mode disabled
+# ATE=1, ATE boot mode enabled
+# Syntax: -c "set ATE {0}"
+# Syntax: -c "set ATE {1}"
+#
+# CORELIST
+# Specify available physical cores by number
+# Example syntax to attach to physical cores 16 and 17
+# Syntax: -c "set CORELIST {16 17}"
+#
+# COREMASK_0
+# Specify available physical cores 0-63 by mask
+# Example syntax to connect to physical cores 16 and 17
+# Syntax: -c "set COREMASK_0 {0x0000000000030000}"
+#
+# COREMASK_1
+# Specify available physical cores 64-127 by mask
+# Example syntax to connect to physical cores 94 and 95
+# Syntax: -c "set COREMASK_1 {0x00000000C0000000}"
+#
+# COREMASK_2
+# Specify available physical cores 128 and above by mask
+# Example syntax to connect to physical cores 128 and 129
+# Syntax: -c "set COREMASK_2 {0x0000000000000003}"
+
+# Board File Argument Description
+#
+# These optional arguments are defined in the board file and
+# referenced by the target file. See the corresponding board
+# files for examples of their use.
+#
+# SMP_STR
+# This option is used primarily for a dual socket system and it is not
+# recommended for a single socket setup. This option configures whether
+# the SMP ARMv8 core grouping is maintained at the board or target cfg level.
+# Specify the option if the SMP core grouping is defined at the board level.
+# Do not specify if the SMP core grouping is defined at the chip level.
+# If not specified, defaults to SMP core grouping defined per socket.
+# If specified, "SMP_STR=target smp", the SMP core grouping is maintained
+# at the board cfg level.
+# Used in conjunction with the SPLITSMP option to group two chips into
+# a single SMP configuration or maintain as two separate SMP sessions.
+#
+# CORE_INDEX_OFFSET
+# Specifies the starting logical core index value.
+# Used for dual-socket systems.
+# For socket #0, set to 0
+# For socket #1, set the starting logical core based from
+# the last logical core on socket #0.
+# If not specified, defaults to 0
+
+#
+# Configure defaults for target
+# These settings can be overridden in the board configuration file
+#
+
+if { [info exists SMP_STR] } {
+	# SMP configured at the dual socket board level
+	set _SMP_STR $SMP_STR
+} else {
+	# SMP configured at the single socket target level
+	set _SMP_STR "target smp"
+}
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME s0
+}
+
+if { [info exists CORE_INDEX_OFFSET] } {
+	set _CORE_INDEX_OFFSET $CORE_INDEX_OFFSET
+} else {
+	set _CORE_INDEX_OFFSET 0
+}
+
+if { [info exists ENDIAN] } {
+	set _ENDIAN $ENDIAN
+} else {
+	set _ENDIAN little
+}
+
+if { [info exists CORELIST] } {
+	set _CORELIST $CORELIST
+} else {
+	if { [info exists COREMASK_0] } {
+		set _COREMASK_0 $COREMASK_0
+	} else {
+		set _COREMASK_0 0x0
+	}
+
+	if { [info exists COREMASK_1] } {
+		set _COREMASK_1 $COREMASK_1
+	} else {
+		set _COREMASK_1 0x0
+	}
+
+	if { [info exists COREMASK_2] } {
+		set _COREMASK_2 $COREMASK_2
+	} else {
+		set _COREMASK_2 0x0
+	}
+
+	set _CORELIST {}
+
+	set corenum 0
+	set _MASK 0x1
+	for {set i 0} {$i < 64} {incr i} {
+		if { [expr {$_COREMASK_0 & $_MASK}] != 0x0 } {
+			set _CORELIST "$_CORELIST $corenum"
+		}
+		set _MASK [expr {$_MASK << 0x1}]
+		incr corenum
+	}
+
+	set _MASK 0x1
+	for {set i 0} {$i < 64} {incr i} {
+		if { [expr {$_COREMASK_1 & $_MASK}] != 0x0 } {
+			set _CORELIST "$_CORELIST $corenum"
+		}
+		set _MASK [expr {$_MASK << 0x1}]
+		incr corenum
+	}
+
+	set _MASK 0x1
+	for {set i 0} {$i < 64} {incr i} {
+		if { [expr {$_COREMASK_2 & $_MASK}] != 0x0 } {
+			set _CORELIST "$_CORELIST $corenum"
+		}
+		set _MASK [expr {$_MASK << 0x1}]
+		incr corenum
+	}
+}
+
+#
+# Definitions
+#
+
+set _SYSTAPNAME sys
+
+set _TARGETNAME_PCP    pcp
+set _TARGETNAME_SECPRO secpro
+set _TARGETNAME_MPRO   mpro
+set _TARGETNAME_BSV    bsv
+
+set _TAPNAME_SYS $_CHIPNAME.$_SYSTAPNAME.tap
+set _DAPNAME_SYS $_CHIPNAME.$_SYSTAPNAME.dap
+
+set _AP_ROM         0x00000000
+set _AP_PCP_APB     0x00010000
+set _AP_PCP_AXI     0x00020000
+set _AP_SECPRO_AHB  0x00030000
+set _AP_MPRO_AHB    0x00040000
+set _AP_BSV         0x00050000
+
+if {! [info exists idcode] } {
+	puts "FATAL ERROR: IDCODE NOT DETECTED"
+	shutdown
+}
+
+set ver [expr {($idcode >> 28) & 0xF}]
+if {$ver == 3} {
+	set chip ac03
+	set options {-ignore-syspwrupack -ignore-dbgpwrupack}
+} else {
+	set chip ac04
+	set options {}
+}
+
+#
+# Configure JTAG DAP
+#
+
+dap create $_DAPNAME_SYS -adiv6 -chain-position $_TAPNAME_SYS {*}$options
+
+#
+# Create the DAP BSV AP target for the BSV block
+#
+
+target create $_CHIPNAME.$_TARGETNAME_BSV mem_ap -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_BSV
+
+if { [info exists LCS] && [expr {"$LCS"!="0"}] } {
+	#
+	# Create the DAP AHB-AP MEM-AP target for the SECPRO CPU
+	#
+
+	target create $_CHIPNAME.$_TARGETNAME_SECPRO.ahb mem_ap -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_SECPRO_AHB
+	if { [info exists ATE] && [expr {"$ATE"!="0"}] } {
+		$_CHIPNAME.$_TARGETNAME_SECPRO.ahb configure -defer-examine
+	}
+
+	#
+	# Configure target SECPRO CPU
+	#
+
+	target create $_CHIPNAME.$_TARGETNAME_SECPRO cortex_m -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_SECPRO_AHB
+	if { [info exists ATE] && [expr {"$ATE"!="0"}] } {
+		$_CHIPNAME.$_TARGETNAME_SECPRO configure -defer-examine
+	}
+
+	#
+	# Create the DAP AHB-AP MEM-AP target for the MPRO CPU
+	#
+
+	target create $_CHIPNAME.$_TARGETNAME_MPRO.ahb mem_ap -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_MPRO_AHB
+	if { [info exists ATE] && [expr {"$ATE"!="0"}] } {
+		$_CHIPNAME.$_TARGETNAME_MPRO.ahb configure -defer-examine
+	}
+
+	#
+	# Configure target MPRO CPU
+	#
+
+	target create $_CHIPNAME.$_TARGETNAME_MPRO cortex_m -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_MPRO_AHB
+	if { [info exists ATE] && [expr {"$ATE"!="0"}] } {
+		$_CHIPNAME.$_TARGETNAME_MPRO configure -defer-examine
+	}
+}
+
+#
+# Create the DAP APB-AP MEM-AP target for the PCP block
+#
+
+target create $_CHIPNAME.$_TARGETNAME_PCP.apb mem_ap -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_PCP_APB
+if { [info exists ATE] && [expr {"$ATE"!="0"}] } {
+	$_CHIPNAME.$_TARGETNAME_PCP.apb configure -defer-examine
+}
+
+#
+# Create the DAP AXI-AP MEM-AP target for the PCP block
+#
+
+target create $_CHIPNAME.$_TARGETNAME_PCP.axi mem_ap -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_PCP_AXI
+if { [info exists ATE] && [expr {"$ATE"!="0"}] } {
+	$_CHIPNAME.$_TARGETNAME_PCP.axi configure -defer-examine
+}
+
+# Set CSW register value default correctly for AXI accessible device memory
+# Select the correct Access Port Number
+$_DAPNAME_SYS apsel $_AP_PCP_AXI
+
+#First set the CSW to OpenOCD's internal default
+$_DAPNAME_SYS apcsw default
+
+# Set Domain[1:0]=b'11  (CSW[14:13]=b'11)
+# Set Cache[3:0]=b'0000 (CSW[27:24]=b'0000)
+# Porter Cfg registers require secure access. AxPROT[1] (CSW[29]) must be b'0'.
+# Set AxPROT[2:0]=b'000 (CSW[30:28]=b'000) for an Unpriveleged, Secure, Data access.
+$_DAPNAME_SYS apcsw 0x00006000 0x7F006000
+
+#
+# Configure target CPUs
+#
+
+# Zero index core number being operated on
+set _core 0
+
+# Zero index CCM number being operated on
+set _ccm 0
+
+# Base APB address of the Debug Bus in the system
+set _apb_base 0xA0000000
+
+# APB address offset and increment value for each CPM in the system
+set _apb_ccm_offset 0
+set _apb_ccm_incr 0x400000
+
+# APB increment value for each CTI and Debug block per CPM
+set _apb_cti_incr 0x70000
+set _apb_dbg_incr 0x80000
+
+# Set the logical core numbering starting value
+set logical_index $_CORE_INDEX_OFFSET
+
+while { $_CORELIST != {} } {
+	if { $chip == {ac03} } {
+		if { [expr {($_ccm % 6) != 2}] && [expr {($_ccm % 6) != 3}] } {
+			# Every 1st (ccm=0), 2nd (ccm=1), 5th (ccm=4) and 6th (ccm=5) CCM is a CCM4 containing 4 PEs
+			set _num_pe 4
+		} else {
+			# Every 3rd (ccm=2) and 4th (ccm=3) CCM is a CCM2 containing 2 PEs
+			set _num_pe 2
+		}
+	} else {
+		set _num_pe 4
+	}
+
+	set _pe 0
+	set _apb_cti_offset 0x70000
+	set _apb_dbg_offset 0x200000
+
+	while { $_pe < $_num_pe } {
+		if { [lsearch -inline $_CORELIST $_core] == $_core } {
+			# Remove the core number from the list
+			set _CORELIST [lsearch -inline -all -not -exact $_CORELIST $_core]
+
+			# Format a string to reference which CPU target to use
+			if { [info exists SPLITSMP] } {
+				eval "set _TARGETNAME $_CHIPNAME.${_TARGETNAME_PCP}_$logical_index"
+			} else {
+				eval "set _TARGETNAME ${_TARGETNAME_PCP}_$logical_index"
+			}
+
+			# Create and configure Cross Trigger Interface (CTI) - required for halt and resume
+			set _CTINAME $_TARGETNAME.cti
+			set _cti_addr [expr {$_apb_base + $_apb_ccm_offset + $_apb_cti_offset}]
+			cti create $_CTINAME -dap $_DAPNAME_SYS -ap-num $_AP_PCP_APB -baseaddr $_cti_addr
+
+			# Create the target
+			set _dbg_addr [expr {$_apb_base + $_apb_ccm_offset + $_apb_dbg_offset}]
+			target create $_TARGETNAME aarch64 -endian $_ENDIAN -dap $_DAPNAME_SYS -ap-num $_AP_PCP_APB -dbgbase $_dbg_addr -rtos hwthread -cti $_CTINAME -coreid $logical_index
+
+			# Build string used to enable SMP mode for the ARMv8 CPU cores
+			set _SMP_STR "$_SMP_STR $_TARGETNAME"
+
+			# Mesh must be initialized before PE cores can be accessed. Defer examination.
+			$_TARGETNAME configure -defer-examine
+
+			# Clear CTI output/input enables that are not configured by OpenOCD for aarch64
+			$_TARGETNAME configure -event reset-init [subst {
+				$_CTINAME write INEN0 0x00000000
+				$_CTINAME write INEN1 0x00000000
+				$_CTINAME write INEN2 0x00000000
+				$_CTINAME write INEN3 0x00000000
+				$_CTINAME write INEN4 0x00000000
+				$_CTINAME write INEN5 0x00000000
+				$_CTINAME write INEN6 0x00000000
+				$_CTINAME write INEN7 0x00000000
+				$_CTINAME write INEN8 0x00000000
+
+				$_CTINAME write OUTEN0 0x00000000
+				$_CTINAME write OUTEN1 0x00000000
+				$_CTINAME write OUTEN2 0x00000000
+				$_CTINAME write OUTEN3 0x00000000
+				$_CTINAME write OUTEN4 0x00000000
+				$_CTINAME write OUTEN5 0x00000000
+				$_CTINAME write OUTEN6 0x00000000
+				$_CTINAME write OUTEN7 0x00000000
+				$_CTINAME write OUTEN8 0x00000000
+			}]
+
+			incr logical_index
+		}
+
+		incr _core
+		incr _pe
+		set _apb_cti_offset [expr {$_apb_cti_offset + $_apb_cti_incr}]
+		set _apb_dbg_offset [expr {$_apb_dbg_offset + $_apb_dbg_incr}]
+	}
+
+	incr _ccm
+	set _apb_ccm_offset [expr {$_apb_ccm_offset + $_apb_ccm_incr}]
+}
+
+if { [info exists SMP_STR] } {
+	# Return updated SMP configuration string back to board level
+	set SMP_STR $_SMP_STR
+} else {
+	# For single socket per SMP configuration, evaluate the string
+	eval $_SMP_STR
+}
+
+if { [info exists CORE_INDEX_OFFSET] } {
+	# For multi-socket, return total number of cores back to board level
+	set CORE_INDEX_OFFSET $logical_index
+}
diff --git a/tcl/target/ampere_ac03_1s_tap.cfg b/tcl/target/ampere_ac03_1s_tap.cfg
new file mode 100644
index 000000000..0b61e7720
--- /dev/null
+++ b/tcl/target/ampere_ac03_1s_tap.cfg
@@ -0,0 +1,48 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# OpenOCD Target Configuration for the AmpereOne and AmpereOne X processors
+#
+# Copyright (c) 2021-2023, Ampere Computing LLC
+#
+
+#
+# Configure JTAG TAP
+#
+
+set _CHIPNAME_S0 s0
+
+set _SYSTAPNAME sys
+set _DFTTAPNAME dft
+
+set SYSTAPID_AC03 0x3BA06477
+set SYSTAPID_AC04 0x4BA06477
+
+set DFTTAPID_AC03_A0 0x03100A2D
+set DFTTAPID_AC03_B0 0x13100A2D
+set DFTTAPID_AC04_A0 0x04100A2D
+set DFTTAPID_AC04_1_A0 0x04101A2D
+
+if { [info exists DFTTAPID] } {
+	jtag newtap $_CHIPNAME_S0 $_DFTTAPNAME.tap -irlen 8 -ircapture 0x1 -irmask 0x3 -expected-id $DFTTAPID
+} else {
+	jtag newtap $_CHIPNAME_S0 $_DFTTAPNAME.tap -irlen 8 -ircapture 0x1 -irmask 0x3 -expected-id $DFTTAPID_AC03_A0 -expected-id $DFTTAPID_AC03_B0 -expected-id $DFTTAPID_AC04_A0 -expected-id $DFTTAPID_AC04_1_A0
+}
+
+if { [info exists SYSTAPID] } {
+	jtag newtap $_CHIPNAME_S0 $_SYSTAPNAME.tap -irlen 4 -ircapture 0x1 -irmask 0x3 -expected-id $SYSTAPID
+} else {
+	jtag newtap $_CHIPNAME_S0 $_SYSTAPNAME.tap -irlen 4 -ircapture 0x1 -irmask 0x3 -expected-id $SYSTAPID_AC03 -expected-id $SYSTAPID_AC04
+}
+
+#
+# Initialize the JTAG chain for the defined TAPs
+# Detect AC03 or AC04 chip
+#
+
+set result [capture {jtag init}]
+set char_start [string first $_CHIPNAME_S0.$_SYSTAPNAME.tap $result]
+if { $char_start >= 0 } {
+	set result [string range $result $char_start end]
+	lassign $result c0 c1 c2 idcode
+	echo "IDCODE found: $idcode"
+}
diff --git a/tcl/target/ampere_ac03_2s_tap.cfg b/tcl/target/ampere_ac03_2s_tap.cfg
new file mode 100644
index 000000000..f9762a110
--- /dev/null
+++ b/tcl/target/ampere_ac03_2s_tap.cfg
@@ -0,0 +1,61 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# OpenOCD Target Configuration for the AmpereOne and AmpereOne X processors
+#
+# Copyright (c) 2021-2023, Ampere Computing LLC
+#
+
+#
+# Configure JTAG TAP
+#
+
+set _CHIPNAME_S0 s0
+set _CHIPNAME_S1 s1
+
+set _SYSTAPNAME sys
+set _DFTTAPNAME dft
+
+set SYSTAPID_AC03 0x3BA06477
+set SYSTAPID_AC04 0x4BA06477
+
+set DFTTAPID_AC03_A0 0x03100A2D
+set DFTTAPID_AC03_B0 0x13100A2D
+set DFTTAPID_AC04_A0 0x04100A2D
+set DFTTAPID_AC04_1_A0 0x04101A2D
+
+if { [info exists DFTTAPID] } {
+	jtag newtap $_CHIPNAME_S1 $_DFTTAPNAME.tap -irlen 8 -ircapture 0x1 -irmask 0x3 -expected-id $DFTTAPID
+} else {
+	jtag newtap $_CHIPNAME_S1 $_DFTTAPNAME.tap -irlen 8 -ircapture 0x1 -irmask 0x3 -expected-id $DFTTAPID_AC03_A0 -expected-id $DFTTAPID_AC03_B0 -expected-id $DFTTAPID_AC04_A0 -expected-id $DFTTAPID_AC04_1_A0
+}
+
+if { [info exists SYSTAPID] } {
+	jtag newtap $_CHIPNAME_S1 $_SYSTAPNAME.tap -irlen 4 -ircapture 0x1 -irmask 0x3 -expected-id $SYSTAPID
+} else {
+	jtag newtap $_CHIPNAME_S1 $_SYSTAPNAME.tap -irlen 4 -ircapture 0x1 -irmask 0x3 -expected-id $SYSTAPID_AC03 -expected-id $SYSTAPID_AC04
+}
+
+if { [info exists DFTTAPID] } {
+	jtag newtap $_CHIPNAME_S0 $_DFTTAPNAME.tap -irlen 8 -ircapture 0x1 -irmask 0x3 -expected-id $DFTTAPID
+} else {
+	jtag newtap $_CHIPNAME_S0 $_DFTTAPNAME.tap -irlen 8 -ircapture 0x1 -irmask 0x3 -expected-id $DFTTAPID_AC03_A0 -expected-id $DFTTAPID_AC03_B0 -expected-id $DFTTAPID_AC04_A0 -expected-id $DFTTAPID_AC04_1_A0
+}
+
+if { [info exists SYSTAPID] } {
+	jtag newtap $_CHIPNAME_S0 $_SYSTAPNAME.tap -irlen 4 -ircapture 0x1 -irmask 0x3 -expected-id $SYSTAPID
+} else {
+	jtag newtap $_CHIPNAME_S0 $_SYSTAPNAME.tap -irlen 4 -ircapture 0x1 -irmask 0x3 -expected-id $SYSTAPID_AC03 -expected-id $SYSTAPID_AC04
+}
+
+#
+# Initialize the JTAG chain for the defined TAPs
+# Detect AC03 or AC04 chip
+#
+
+set result [capture {jtag init}]
+set char_start [string first $_CHIPNAME_S0.$_SYSTAPNAME.tap $result]
+if { $char_start >= 0 } {
+	set result [string range $result $char_start end]
+	lassign $result c0 c1 c2 idcode
+	echo "IDCODE found: $idcode"
+}
-- 
2.25.1

