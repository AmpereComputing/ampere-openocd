From 22fbbfa04ea4ada9131ac02f38c3316b6a7372fa Mon Sep 17 00:00:00 2001
From: Kevin Burke <kevinb@os.amperecomputing.com>
Date: Fri, 3 Apr 2020 18:33:06 -0400
Subject: [PATCH 09/32] target/aarch64: Add 'steponly' command for SMP

The OpenOCD 'step' command defaults to starting all other
targets in an SMP configuration prior to stepping the selected
target. Other industry standard debuggers provide a mechanism
to step only the selected target.

The 'aarch64 steponly [on/off]' command can change this default
behavior to match the behavior seen on other industry
standard debuggers.

- 'aarch64 steponly on' prevents the SMP targets from starting
  ('resume') when issuing the step command.
- 'aarch64 steponly off' restores the default behavior.
- 'aarch64 steponly' shows the current state (on or off)
  being used.

Tested on an Ampere eMAG8180 and Quicksilver silicon.
Tested OpenOCD with GDB Client functionality.

Change-Id: I6d93ecbc8d3b3a94bd34b14625fefbc23f9564c8
Signed-off-by: Kevin Burke <kevinb@os.amperecomputing.com>
Signed-off-by: Daniel Goehring <dgoehrin@os.amperecomputing.com>
---
 src/target/aarch64.c | 83 ++++++++++++++++++++++++++++++++++++--------
 src/target/aarch64.h |  9 +++++
 2 files changed, 77 insertions(+), 15 deletions(-)

diff --git a/src/target/aarch64.c b/src/target/aarch64.c
index e4d420f07..46ef10613 100644
--- a/src/target/aarch64.c
+++ b/src/target/aarch64.c
@@ -1,6 +1,8 @@
 /***************************************************************************
  *   Copyright (C) 2015 by David Ung                                       *
  *                                                                         *
+ *   Copyright (C) 2019-2020, Ampere Computing LLC                         *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -1096,6 +1098,7 @@ static int aarch64_step(struct target *target, int current, target_addr_t addres
 {
 	struct armv8_common *armv8 = target_to_armv8(target);
 	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct target_list *head;
 	int saved_retval = ERROR_OK;
 	int retval;
 	uint32_t edecr;
@@ -1124,23 +1127,33 @@ static int aarch64_step(struct target *target, int current, target_addr_t addres
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (target->smp && (current == 1)) {
-		/*
-		 * isolate current target so that it doesn't get resumed
-		 * together with the others
-		 */
-		retval = arm_cti_gate_channel(armv8->cti, 1);
-		/* resume all other targets in the group */
-		if (retval == ERROR_OK)
-			retval = aarch64_step_restart_smp(target);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("Failed to restart non-stepping targets in SMP group");
-			return retval;
+	if (target->smp) {
+		if ((current != 1) || (aarch64->step_only_mode == AARCH64_STEPONLY_ON)) {
+			struct target *curr = target;
+
+			foreach_smp_target(head, target->smp_targets) {
+				curr = head->target;
+				if ((curr != target) && (curr->debug_reason == DBG_REASON_SINGLESTEP))
+					curr->debug_reason = DBG_REASON_DBGRQ;
+			}
+		} else {
+			/*
+			 * isolate current target so that it doesn't get resumed
+			 * together with the others
+			 */
+			retval = arm_cti_gate_channel(armv8->cti, 1);
+			/* resume all other targets in the group */
+			if (retval == ERROR_OK)
+				retval = aarch64_step_restart_smp(target);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Failed to restart non-stepping targets in SMP group");
+				return retval;
+			}
+			LOG_DEBUG("Restarted all non-stepping targets in SMP group");
 		}
-		LOG_DEBUG("Restarted all non-stepping targets in SMP group");
 	}
 
-	/* all other targets running, restore and restart the current target */
+	/* all other targets running in SMP, restore and restart the current target */
 	retval = aarch64_restore_one(target, current, &address, 0, 0);
 	if (retval == ERROR_OK)
 		retval = aarch64_restart_one(target, RESTART_LAZY);
@@ -2687,7 +2700,6 @@ static int aarch64_examine_first(struct target *target)
 
 	target->state = TARGET_UNKNOWN;
 	target->debug_reason = DBG_REASON_NOTHALTED;
-	aarch64->isrmasking_mode = AARCH64_ISRMASK_ON;
 	target_set_examined(target);
 	return ERROR_OK;
 }
@@ -2726,6 +2738,8 @@ static int aarch64_init_arch_info(struct target *target,
 
 	/* Setup struct aarch64_common */
 	aarch64->common_magic = AARCH64_COMMON_MAGIC;
+	aarch64->isrmasking_mode = AARCH64_ISRMASK_ON;
+	aarch64->step_only_mode = AARCH64_STEPONLY_OFF; /* resume smp cpus while stepping single cpu */
 	armv8->arm.dap = dap;
 
 	/* register arch-specific functions */
@@ -2967,6 +2981,38 @@ COMMAND_HANDLER(aarch64_mask_interrupts_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(aarch64_step_only_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+
+	static const struct jim_nvp nvp_steponly_modes[] = {
+		{ .name = "off", .value = AARCH64_STEPONLY_OFF },
+		{ .name = "on", .value = AARCH64_STEPONLY_ON },
+		{ .name = NULL, .value = -1 },
+	};
+	const struct jim_nvp *n;
+
+	if (CMD_ARGC > 0) {
+		n = jim_nvp_name2value_simple(nvp_steponly_modes, CMD_ARGV[0]);
+		if (n->name == NULL) {
+			LOG_ERROR("Unknown parameter: %s - should be off or on", CMD_ARGV[0]);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+		foreach_smp_target(head, target->smp_targets) {
+			aarch64 = target_to_aarch64(head->target);
+			aarch64->step_only_mode = n->value;
+			/* head->target->step_only_mode = n->value; */
+		}
+	}
+
+	n = jim_nvp_value2name_simple(nvp_steponly_modes, aarch64->step_only_mode);
+	command_print(CMD, "aarch64 step only mode %s", n->name);
+
+	return ERROR_OK;
+}
+
 static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 {
 	struct command *c = jim_to_command(interp);
@@ -3134,6 +3180,13 @@ static const struct command_registration aarch64_exec_command_handlers[] = {
 		.help = "mask aarch64 interrupts during single-step",
 		.usage = "['on'|'off']",
 	},
+	{
+		.name = "steponly",
+		.handler = aarch64_step_only_command,
+		.mode = COMMAND_ANY,
+		.help = "do not resume aarch64 smp cpus during single-step",
+		.usage = "['on'|'off']",
+	},
 	{
 		.name = "mcr",
 		.mode = COMMAND_EXEC,
diff --git a/src/target/aarch64.h b/src/target/aarch64.h
index b57361f88..30769045e 100644
--- a/src/target/aarch64.h
+++ b/src/target/aarch64.h
@@ -1,6 +1,8 @@
 /***************************************************************************
  *   Copyright (C) 2015 by David Ung                                       *
  *                                                                         *
+ *   Copyright (C) 2019, Ampere Computing LLC                              *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -41,6 +43,11 @@ enum aarch64_isrmasking_mode {
 	AARCH64_ISRMASK_ON,
 };
 
+enum aarch64_steponly_mode {
+	AARCH64_STEPONLY_OFF,
+	AARCH64_STEPONLY_ON,
+};
+
 struct aarch64_brp {
 	int used;
 	int type;
@@ -70,6 +77,8 @@ struct aarch64_common {
 	struct armv8_common armv8_common;
 
 	enum aarch64_isrmasking_mode isrmasking_mode;
+
+	enum aarch64_steponly_mode step_only_mode;
 };
 
 static inline struct aarch64_common *
-- 
2.25.1

