From f355d1f8809e946b2f42b01d7393c6bbde1742e8 Mon Sep 17 00:00:00 2001
From: Kevin Burke <kevinb@os.amperecomputing.com>
Date: Fri, 3 Apr 2020 18:33:06 -0400
Subject: [PATCH 05/34] target/aarch64: add 'steponly' command for SMP

The OpenOCD 'step' command defaults to starting all other
targets in an SMP configuration prior to stepping the selected
target. Other industry standard debuggers provide a mechanism
to step only the selected target.

The 'aarch64 steponly [on/off]' command can change this default
behavior to match the behavior seen on other industry
standard debuggers.

- 'aarch64 steponly on' prevents the SMP targets from starting
  ('resume') when issuing the step command.
- 'aarch64 steponly off' restores the default behavior.
- 'aarch64 steponly' shows the current state (on or off)
  being used.

Tested on an Ampere eMAG8180 and Quicksilver silicon.
Tested OpenOCD with GDB Client functionality.

Change-Id: I6d93ecbc8d3b3a94bd34b14625fefbc23f9564c8
Signed-off-by: Kevin Burke <kevinb@os.amperecomputing.com>
Signed-off-by: Daniel Goehring <dgoehrin@os.amperecomputing.com>
---
 src/target/aarch64.c | 82 ++++++++++++++++++++++++++++++++++++--------
 src/target/aarch64.h |  8 +++++
 2 files changed, 75 insertions(+), 15 deletions(-)

diff --git a/src/target/aarch64.c b/src/target/aarch64.c
index d25c7d30e..785684562 100644
--- a/src/target/aarch64.c
+++ b/src/target/aarch64.c
@@ -2,6 +2,7 @@
 
 /***************************************************************************
  *   Copyright (C) 2015 by David Ung                                       *
+ *   Copyright (C) 2019-2023, Ampere Computing LLC                         *
  *                                                                         *
  ***************************************************************************/
 
@@ -1090,6 +1091,7 @@ static int aarch64_step(struct target *target, int current, target_addr_t addres
 {
 	struct armv8_common *armv8 = target_to_armv8(target);
 	struct aarch64_common *aarch64 = target_to_aarch64(target);
+	struct target_list *head;
 	int saved_retval = ERROR_OK;
 	int poll_retval;
 	int retval;
@@ -1119,23 +1121,33 @@ static int aarch64_step(struct target *target, int current, target_addr_t addres
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (target->smp && (current == 1)) {
-		/*
-		 * isolate current target so that it doesn't get resumed
-		 * together with the others
-		 */
-		retval = arm_cti_gate_channel(armv8->cti, 1);
-		/* resume all other targets in the group */
-		if (retval == ERROR_OK)
-			retval = aarch64_step_restart_smp(target);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("Failed to restart non-stepping targets in SMP group");
-			return retval;
+	if (target->smp) {
+		if (current != 1 || aarch64->step_only_mode == AARCH64_STEPONLY_ON) {
+			struct target *curr = target;
+
+			foreach_smp_target(head, target->smp_targets) {
+				curr = head->target;
+				if (curr != target && curr->debug_reason == DBG_REASON_SINGLESTEP)
+					curr->debug_reason = DBG_REASON_DBGRQ;
+			}
+		} else {
+			/*
+			 * isolate current target so that it doesn't get resumed
+			 * together with the others
+			 */
+			retval = arm_cti_gate_channel(armv8->cti, 1);
+			/* resume all other targets in the group */
+			if (retval == ERROR_OK)
+				retval = aarch64_step_restart_smp(target);
+			if (retval != ERROR_OK) {
+				LOG_ERROR("Failed to restart non-stepping targets in SMP group");
+				return retval;
+			}
+			LOG_DEBUG("Restarted all non-stepping targets in SMP group");
 		}
-		LOG_DEBUG("Restarted all non-stepping targets in SMP group");
 	}
 
-	/* all other targets running, restore and restart the current target */
+	/* all other targets running in SMP, restore and restart the current target */
 	retval = aarch64_restore_one(target, current, &address, 0, 0);
 	if (retval == ERROR_OK)
 		retval = aarch64_restart_one(target, RESTART_LAZY);
@@ -2684,7 +2696,6 @@ static int aarch64_examine_first(struct target *target)
 
 	target->state = TARGET_UNKNOWN;
 	target->debug_reason = DBG_REASON_NOTHALTED;
-	aarch64->isrmasking_mode = AARCH64_ISRMASK_ON;
 	target_set_examined(target);
 	return ERROR_OK;
 }
@@ -2726,6 +2737,8 @@ static int aarch64_init_arch_info(struct target *target,
 
 	/* Setup struct aarch64_common */
 	aarch64->common_magic = AARCH64_COMMON_MAGIC;
+	aarch64->isrmasking_mode = AARCH64_ISRMASK_ON;
+	aarch64->step_only_mode = AARCH64_STEPONLY_OFF; /* resume smp cpus while stepping single cpu */
 	armv8->arm.dap = dap;
 
 	/* register arch-specific functions */
@@ -2992,6 +3005,38 @@ COMMAND_HANDLER(aarch64_mask_interrupts_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(aarch64_step_only_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	struct aarch64_common *aarch64 = target_to_aarch64(target);
+
+	static const struct jim_nvp nvp_steponly_modes[] = {
+		{ .name = "off", .value = AARCH64_STEPONLY_OFF },
+		{ .name = "on", .value = AARCH64_STEPONLY_ON },
+		{ .name = NULL, .value = -1 },
+	};
+	const struct jim_nvp *n;
+
+	if (CMD_ARGC > 0) {
+		n = jim_nvp_name2value_simple(nvp_steponly_modes, CMD_ARGV[0]);
+		if (!n->name) {
+			LOG_ERROR("Unknown parameter: %s - should be off or on", CMD_ARGV[0]);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+		foreach_smp_target(head, target->smp_targets) {
+			aarch64 = target_to_aarch64(head->target);
+			aarch64->step_only_mode = n->value;
+			/* head->target->step_only_mode = n->value; */
+		}
+	}
+
+	n = jim_nvp_value2name_simple(nvp_steponly_modes, aarch64->step_only_mode);
+	command_print(CMD, "aarch64 step only mode %s", n->name);
+
+	return ERROR_OK;
+}
+
 COMMAND_HANDLER(aarch64_mcrmrc_command)
 {
 	bool is_mcr = false;
@@ -3124,6 +3169,13 @@ static const struct command_registration aarch64_exec_command_handlers[] = {
 		.help = "mask aarch64 interrupts during single-step",
 		.usage = "['on'|'off']",
 	},
+	{
+		.name = "steponly",
+		.handler = aarch64_step_only_command,
+		.mode = COMMAND_ANY,
+		.help = "do not resume aarch64 smp cpus during single-step",
+		.usage = "['on'|'off']",
+	},
 	{
 		.name = "mcr",
 		.mode = COMMAND_EXEC,
diff --git a/src/target/aarch64.h b/src/target/aarch64.h
index 2721fe747..7c321ee2f 100644
--- a/src/target/aarch64.h
+++ b/src/target/aarch64.h
@@ -2,6 +2,7 @@
 
 /***************************************************************************
  *   Copyright (C) 2015 by David Ung                                       *
+ *   Copyright (C) 2019, Ampere Computing LLC                              *
  ***************************************************************************/
 
 #ifndef OPENOCD_TARGET_AARCH64_H
@@ -29,6 +30,11 @@ enum aarch64_isrmasking_mode {
 	AARCH64_ISRMASK_ON,
 };
 
+enum aarch64_steponly_mode {
+	AARCH64_STEPONLY_OFF,
+	AARCH64_STEPONLY_ON,
+};
+
 struct aarch64_brp {
 	int used;
 	int type;
@@ -58,6 +64,8 @@ struct aarch64_common {
 	struct aarch64_brp *wp_list;
 
 	enum aarch64_isrmasking_mode isrmasking_mode;
+
+	enum aarch64_steponly_mode step_only_mode;
 };
 
 static inline struct aarch64_common *
-- 
2.25.1

